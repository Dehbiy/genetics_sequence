\documentclass[10pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}

%\usepackage[T1]{fontenc}
\usepackage{enumerate}

%%%% POUR FAIRE TENIR SUR UNE PAGE RECTO-VERSO.....
\textwidth 18.5cm
\oddsidemargin -1.75cm
\evensidemargin -1.75cm
\textheight 28.0cm
\topmargin -3.0cm

%   \textwidth 18cm
   %\oddsidemargin -1.5cm
   %\evensidemargin -1.5cm
   %\textheight 26.0cm
   %\topmargin -2.0cm
 


\begin{document}

\thispagestyle{empty}

\noindent\centerline{\bf\large Questionnaire  TP AOD 2023-2024 à compléter et rendre sur teide  } \\
Binôme 
(ELAASRI\textsubscript{1} YOUSSEF\textsubscript{1} --
 DEHBI\textsubscript{2} YAKOUB\textsubscript{2})
\,: \dotfill

\section{Préambule 1 point}.
Le programme récursif avec mémoisation fourni alloue une mémoire de taille $N.M$.
Il génère une erreur d'exécution sur le test 5 (c-dessous) . Pourquoi ? \\
Réponse:   La programme récursif avec mémoisation alloue une mémoire de taille $N \times M$, où $N$ et $M$ correspondent aux tailles des séquences en entrée. L'erreur d'exécution observée sur le test 5 est due à une allocation de mémoire excessive lorsque les séquences sont de grandes tailles. Cette allocation dépasse la capacité de mémoire disponible sur le système,
\begin{verbatim}
distanceEdition-recmemo    GCA_024498555.1_ASM2449855v1_genomic.fna 77328790 20236404   \
                           GCF_000001735.4_TAIR10.1_genomic.fna 30808129 19944517 
\end{verbatim}

%%%%%%%%%%%%%%%%%%%
{\noindent\bf{Important}.} Dans toute la suite, on demande des programmes qui allouent un espace mémoire $O(N+M)$.

\section{Programme itératif en espace mémoire $O(N+M)$ (5 points)}
{\em Expliquer très brièvement (2 à 5 lignes max) le principe de votre code, la mémoire utilisée, le sens de parcours des tableaux.}
\vspace*{1.0cm}

On commence le parcours au point $(N, M)$, puis on remplie la table phi de taille $\min(N,M)$ par l'élément calculé précédemment sur le bon indice. Cela permet bien de calculer la valeur courante et ainsi déterminer le en fin la distance voulue.

\vspace*{1.0cm}

Analyse du coût théorique de ce  programme en fonction de $N$ et $M$  en notation $\Theta(...)$ 
\begin{enumerate}
  \item La place mémoire allouée est $\Theta(\min(N,M) + 1)$.
  \item Le nombre d'opérations est de $\Theta(NM)$. Cela vient des deux boucles imbriquées. 
  \item nombre de défauts de cache obligatoires est $\Theta(\min(N, M)/L + (N + M)/L)$.
  \item nombre de défauts de cache si $Z \ll \min(N,M)$ : 
  \[
\text{Nombre de défauts de cache en lecture} = \Theta(\frac{2 \cdot N \cdot M}{L} + \frac{\max(N, M)}{L})
\]
  \[
\text{Nombre de défauts de cache en écriture} = \Theta(\frac{ N \cdot M}{L})
\]
\end{enumerate}

%%%%%%%%%%%%%%%%%%%
\section{Programme cache aware  (3 points)}
{\em Expliquer très brièvement (2 à 5 lignes max) le principe de votre code, la mémoire utilisée, le sens de parcours des tableaux.}
\vspace*{1.0cm}

On divise notre problème en des blocs de taille K. On traite chaque blocs partiellement similaire à l'algorithme itératif. Les calculs des blocs étant dépendants entre eux, on utilise phi de taille $m\min(N, M)$ et ksi de taille K.

\vspace*{1.0cm}

Analyse du coût théorique de ce  programme en fonction de $N$ et $M$  en notation $\Theta(...)$ )
\begin{enumerate}
  \item  l'algorithme n'utilise pas de matrices explicites pour stocker les scores d'alignement. Au lieu de cela, il utilise des tableaux unidimensionnels, tels que 'phi' et 'ksi', pour stocker les valeurs intermédiaires lors du calcul de l'alignement. Ces tableaux unidimensionnels sont utilisés de façon à économiser de l'espace mémoire tout en effectuant des calculs d'alignement.
  L'éspace mémoire alloué est $\Theta(\min(N,M) + \min(K, \max(N,M))) $ où K est la taille des blocs traités. 
  \item Le travail est de  $\Theta(NM)$.
  \item nombre de défauts de cache obligatoires est : $\Theta(\frac{M + N+\min(N,M) + \min(K, \max(N,M))}{L})$.
  \item nombre de défauts de cache si $Z \ll \min(N,M)$ : Pour le programme cache aware, le nombre de défauts de cache dans le cas où  $Z \ll \min(N,M)$ est égale au nombre de défauts de cache obligatoires à condition que K soit assez petit. Dans notre cas on alloue dans chaque blocs on alloue $K+1$ éléments de la séquence génétique $A$ et de $B$, de 'phi et de 'ksi'. Pour un total de $4K + 4$. On conclu donc que $K < Z/4$. (notez que K à la même unité que les élements stockés en phi. Dans notre cas ça sera $\frac{Z}{4 * sizeof(long)}$ donc dans le pc de l'Ensimag, on a choisit K = 120 < 4096/(4*8))
\end{enumerate}

%%%%%%%%%%%%%%%%%%%
\section{Programme cache oblivious  (3 points)}
{\em Expliquer très brièvement (2 à 5 lignes max) le principe de votre code, la mémoire utilisée, le sens de parcours des tableaux.}
\vspace*{1.0cm}

Ce programme est récursif, Il divise le problème en 4 blocs jusqu'à atteindre une taille inférieure à $K$. Afin d'assurer le bon calcul des blocs, on se muni des tables phi et ksi permettant de mémoriser la dernière ligne et colonne calculée au bloc précédent. Nous utilisons aussi une variable corner permettant de mémoriser le valeur retournée au premier bloc dans chaque division.
\vspace*{1.0cm}

Analyse du coût théorique de ce  programme en fonction de $N$ et $M$  en notation $\Theta(...)$ )
\begin{enumerate}
  \item La place mémoire allouée est $\Theta(N + M)$.
  \item Le nombre d'opérations est de $\Theta(NM)$. Cela vient du fait que l'on passe par tous les éléments une fois. 
  \item nombre de défauts de cache obligatoires est $2\Theta(\frac{N + M}{L})$.
  \item nombre de défauts de cache si $Z \ll \min(N,M)$ est le nombre de défauts de cache obligatoires, à condition que la taille des blocs soit assez petite à savoir: $\Theta(2\frac{N + M}{L})$ 
  
\end{enumerate}

\section{Réglage du seuil d'arrêt récursif du programme cache oblivious  (1 point)} 
Comment faites-vous sur une machine donnée pour choisir ce seuil d'arrêt? Quelle valeur avez vous choisi pour les
PC de l'Ensimag? (2 à 3 lignes) 
\vspace*{1.0cm}

On choisit le seuil d'arrêt de sorte qu'on évite le stack overflow. Dans les PC de l'ensimag on a choisit le seuil 120. 
%%%%%%%%%%%%%%%%%%%
\section{Expérimentation (7 points)}

Description de la machine d'expérimentation:  \\
Processeur: Intel® Core™ i5-7500 CPU @ 3.40GHz × 4  --
Mémoire: 32.0 GiB --
Système: Dell Inc. Precision Tower 3420 

\subsection{(3 points) Avec {\tt 
	valgrind --tool =cachegrind --D1=4096,4,64
}} 
\begin{verbatim}
     distanceEdition ba52_recent_omicron.fasta 153 N wuhan_hu_1.fasta 116 M 
\end{verbatim}
en prenant pour $N$ et $M$ les valeurs dans le tableau ci-dessous.


Les paramètres du cache LL de second niveau est : 25165824 B, 64 B, 12-way associative
{\em mettre ici les paramètres: soit ceux indiqués ligne 3
du fichier cachegrind.out.(pid) généré par valgrind: soit ceux par défaut,
soit ceux que vous avez spécifiés à la main
\footnote{par exemple:
{\tt valgrind --tool=cachegrind --D1=4096,4,64 --LL=65536,16,256  ... }
mais ce n'est pas demandé car cela allonge le temps de simulation. } 
 pour LL. }

{\em Le tableau ci-dessous est un exemple,  complété avec vos résultats et 
ensuite analysé.}
\\

{\footnotesize
\begin{tabular}{|r|r||r|r|r||r|r|r||r|r|r||r|r|r||}
\hline
 \multicolumn{2}{|c||}{ } 
& \multicolumn{3}{c||}{récursif mémo}
& \multicolumn{3}{c||}{itératif}
& \multicolumn{3}{c||}{cache aware}
& \multicolumn{3}{c||}{cache oblivious}
\\ \hline
N & M 
& \#Irefs & \#Drefs & \#D1miss % recursif memoisation
& \#Irefs & \#Drefs & \#D1miss % itératif
& \#Irefs & \#Drefs & \#D1miss % cache aware
& \#Irefs & \#Drefs & \#D1miss % cache oblivious
\\ \hline
\hline
1000 & 1000 
& 217,201,492 & 122,122,356 & 4,921,613  % recursif memoisation
& 95,680,889 & 42,291,507 &  146,944 % itératif
& 104,289,188 & 45,579,689 & 7,225  % cache aware
& 115,189,515 & 49,575,428 &  8,606  % cache oblivious
\\ \hline
2000 & 1000 
& 433,378,886 & 243,401,588 & 11,018,455  % recursif memoisation
& 191,643,931 & 84,501,247 & 288,849   % itératif
& 208,648,388 & 91,075,873 &  8,909 % cache aware
& 231,541,079 & 99,711,653 & 8,643  % cache oblivious
\\ \hline
4000 & 1000 
&867,150,984 & 487,365,844 & 23,217,962  % recursif memoisation
&383,467,510  & 168,920,615 & 572,549  % itératif
& 417,286,678 & 182,068,129 & 12,514  % cache aware
& 467,322,572 & 201,923,213 &  14,781 % cache oblivious
\\ \hline
2000 & 2000 
& 867,142,582 & 487,888,539 &  19,886,360 % recursif memoisation
& 381,921,047 & 168,900,561 & 568,471  % itératif
& 416,309,854 & 181,990,011 & 13,257  % cache aware
& 467,322,572 & 201,923,213 &  14,781 % cache oblivious
\\ \hline
4000 & 4000 
& 3,465,865,295 & 1,950,548,734 & 79,965,732  % recursif memoisation
& 1,526,669,501 & 675,280,773 & 2,254,212  % itératif
& 1,664,157,378 & 727,516,631 &  33,887 % cache aware
& 1,840,027,049 & 791,616,114 &  39,208  % cache oblivious
\\ \hline
6000 & 6000 
&7,796,325,757  & 4,387,984,545 & 180,254,425  % recursif memoisation
& 3,434,433,545 & 1,519,210,457 &  5,068,134 % itératif
& 3,743,771,083 & 1,636,674,883 & 62,393 % cache aware
& 4,132,958,065 & 1,776,883,956 & 86,745  % cache oblivious
\\ \hline
8000 & 8000 
& 13,857,955,304 & 7,799,948,116 & 321,061,340  % recursif memoisation
& 6,105,095,382 & 2,700,689,613 &  9,000,372 % itératif
&  6,655,554,504 & 2,909,685,744 & 110,855  % cache aware
& 7,360,085,100 & 3,165,892,692 & 118,363  % cache oblivious
\\ \hline
\hline
\end{tabular}
}

\paragraph{Important: analyse expérimentale:} 
ces mesures expérimentales sont elles en accord avec les coûts analysés théroiquement (justifier)  ? 
Quel algorithme se comporte le mieux avec valgrind et 
les paramètres proposés, pourquoi ?
\vspace*{1.0cm}

Les mesures expérimentales divergent des coûts théoriquement analysés, notamment en termes de valeur, ne correspondant pas à l'estimation théorique (15000 pour N=1000 M=1000 par exemple). Toutefois, il est crucial de noter une optimisation significative en matière de défaut de cache. Cette divergence suggère une complexité dans la relation entre les résultats expérimentaux et les prévisions théoriques, mettant en évidence la nécessité d'une analyse approfondie pour comprendre les facteurs sous-jacents à cet écart et explorer les implications de l'optimisation observée dans le contexte des coûts analysés.

\subsection{(3 points) Sans valgrind, par exécution de la commande :}
{\tt \begin{tabular}{llll}
distanceEdition & GCA\_024498555.1\_ASM2449855v1\_genomic.fna & 77328790 & M \\
                & GCF\_000001735.4\_TAIR10.1\_genomic.fna     & 30808129 & N
\end{tabular}}

On mesure le temps écoulé, le temps CPU et l'énergie consommée avec : {\em  On a utilisé {\tt getrusage} pour le mesure de temp.
% ou {\tt perfstart/perfstop\_and\_display}%
% \footnote{
%     cf {\tt /matieres/4MMAOD6/2023-10-TP-AOD-ADN-Docs-fournis/tp-ADN-distance/srcperf/0-LisezMoi}
% }
\\
L'énergie consommée sur le processeur peut être estimée en regardant le compteur RAPL d'énergie (en microJoule)
pour chaque core avant et après l'exécution et en faisant la différence.
Le compteur du core $K$ est dans le fichier 
\verb+ /sys/class/powercap/intel-rapl/intel-rapl:K/energy_uj + .\\
Par exemple, pour le c{\oe}ur 0: 
\verb+ /sys/class/powercap/intel-rapl/intel-rapl:0/energy_uj +
% Les fonctions fournies 
% {\tt perfstart/perfstop\_and\_display} dans le répertoire
% {\tt /matieres/4MMAOD6/2022-10-TP-AOD-ADN-Docs-fournis/tp-ADN-distance/srcperf} 
% font ces mesures de temps cpu, ecoulé et énergie.
% }

Nota bene: pour avoir un résultat fiable/reproductible (si variailité), 
il est préférable de faire chaque mesure 5 fois et de reporter l'intervalle
de confiance [min, moyenne, max]. 

\begin{tabular}{|r|r||r|r|r||r|r|r||r|r|r||}
\hline
 \multicolumn{2}{|c||}{ } 
& \multicolumn{3}{c||}{itératif}
& \multicolumn{3}{c||}{cache aware}
& \multicolumn{3}{c||}{cache oblivious}
\\ \hline
N & M 
& temps   & temps & energie       % itératif
& temps   & temps & energie       % cache aware
& temps   & temps & energie       % cache oblivious
\\
& 
& cpu     & écoulé&               % itératif
& cpu     & écoulé&               % cache aware
& cpu     & écoulé&               % cache oblivious
\\ \hline
\hline
10000 & 10000 
& 1.02153 & 0.997276 & 5.45083e-06  % itératif
& 1.10251 & 0.996788 &  6.25246e-06 % cache aware
& 1.17387 & 0.993549 &  6.56238e-06 % cache oblivious
\\ \hline
20000 & 20000 
& 4.15685 & 0.999974 &  2.28818e-05 % itératif
& 4.43925 & 0.999929 &  2.63718e-05  % cache aware
& 4.88196 & 0.999798 &  2.71909e-05 % cache oblivious
\\ \hline
30000 & 30000 
& 9.38041 & 0.999758 &  7.17278e-05 % itératif
& 10.0492 & 0.99694 &  5.65044e-05 % cache aware
& 10.9627 & 0.986447 &  8.37965e-05 % cache oblivious
\\ \hline
40000 & 40000 
& 16.6892 & 0.99968 &  0.000127556 % itératif
& 18.0067 & 0.9995 &  0.000106156 % cache aware
& 19.7827 & 0.999557 &  0.000112312 % cache oblivious
\\ \hline
\hline
\end{tabular}
\paragraph{Important: analyse expérimentale:} 
ces mesures expérimentales sont elles en accord avec les coûts analysés théoriquement (justifier)  ? 
Quel algorithme se comporte le mieux avec valgrind et 
les paramètres proposés, pourquoi ?
\vspace*{1.0cm}

Les mesures expérimentales ne concordent pas avec les coûts analysés théoriquement en raison de la prédominance de l'algorithme itératif par rapport aux algorithmes cache aware et cache oblivious. Cette disparité peut être attribuée à plusieurs facteurs. Tout d'abord, l'algorithme itératif a probablement bénéficié d'une optimisation plus poussée au niveau de son fonctionnement interne, ce qui lui confère un avantage lors de l'exécution pratique. De plus, les caractéristiques spécifiques des données ou du matériel sur lequel les expériences ont été menées peuvent avoir favorisé l'algorithme itératif, en le rendant plus adapté à ces conditions particulières.
\subsection{(1 point) Extrapolation: estimation de la durée et de l'énergie pour la commande :}
{\tt \begin{tabular}{llll}
distanceEdition & GCA\_024498555.1\_ASM2449855v1\_genomic.fna & 77328790 & 20236404  \\
                & GCF\_000001735.4\_TAIR10.1\_genomic.fna     & 30808129 & 19944517 
\end{tabular}
}
A partir des résultats précédents, le programme {\em préciser itératif/cache aware/ cache oblivious} est
le plus performant pour la commande ci dessus (test 5); les ressources pour l'exécution seraient environ:
{\em (préciser la méthode de calcul utilisée)} 
\begin{itemize}
\item Temps cpu (en s) : 3000000
\item Energie  (en kWh) : 12.5
\end{itemize}
Question subsidiaire: comment feriez-vous pour avoir un programme s'exécutant en moins de 1 minute ? 
{\em donner le principe en moins d'une ligne, même 1 mot précis suffit! }
\vspace*{1.0cm}

Il faut choisir l'option algo avancé en deuxième semestre.

\end{document}
